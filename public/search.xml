<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>单项链表</title>
      <link href="/2023/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.%E5%8D%95%E9%A1%B9%E5%88%97%E8%A1%A8/"/>
      <url>/2023/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.%E5%8D%95%E9%A1%B9%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>数据结构.单项链表</p><p>链表的定义：</p><p>​在计算机科学中，链表是数据元素的线性集合，其每个元素都指向下一个元素，但是元素在存储上并不连续。</p><p>链表可以分为：</p><p>​单项链表，每个元素只知道其下一个元素是谁。</p><p><img src="/image/dxlb.jpg" alt="截屏2023-09-03 13.50.56"></p><p>​双向链表，每个元素知道其上一个元素和下一个元素，每个元素都有上一个的索引和下一个的索引。</p><p><img src="/image/sxlb.jpg" alt="截屏2023-09-03 13.52.10"></p><p>​循环链表，通常链表的尾节点tail指向null，而循环链表的tail指向的是头节点head。</p><p><img src="/image/xhlv.jpg" alt="截屏2023-09-03 13.54.00"></p><p>链表内还有一种特殊的节点称为哨兵（Sentinel）节点，他不存储数据，用来标示头节点和尾节点，作用是简化边界的判断。</p><p>以下是实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">//头指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;  <span class="comment">//数据</span></span><br><span class="line">        Node next;  <span class="comment">//下一个节点的指针</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//生成构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加第一个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//将新值的值附值给head，就说明head指向新值</span></span><br><span class="line"><span class="comment">//        head = new Node(value, null);</span></span><br><span class="line">        <span class="comment">//链表非空的情况</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(value, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(p.value);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写Iterable遍历</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123; <span class="comment">//是否有下一个元素</span></span><br><span class="line">                <span class="keyword">return</span> p != <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;  <span class="comment">//返回当前值，并且指向下一个元素</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​链表的增删改比数组的快</p><p>​但是，链表的每次查询，都要从头节点开始依次往后面查，所以，查询的效率不如数组。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA之预编译SQL</title>
      <link href="/2023/08/29/JAVA%E4%B9%8B%E9%A2%84%E7%BC%96SQL/"/>
      <url>/2023/08/29/JAVA%E4%B9%8B%E9%A2%84%E7%BC%96SQL/</url>
      
        <content type="html"><![CDATA[<p>JAVA之预编SQL</p><p>预编译SQL能有效的防止sql注入问题。那么首先我们会想到，什么是sql注入。</p><p>sql注入就是利用sql语法上的漏洞，进行注入攻击，能够到达获取数据库信息，或者是在不知道密码的情况下，直接登入网站后台的效果。其攻击方式可以分为：联合查询注入，时间盲注，布尔盲注，堆叠注入，分块注入，DNSlog回显注入，报错注入。下面，我们列举一个最简单的sql注入的例子。</p><p>比如：系统中存在一个最简单的sql注入的漏洞，我们可以利用语法上的错误，将密码那一栏写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or 1=&#x27;1</span><br></pre></td></tr></table></figure><p>那么实际上这条命令传递到后端之后再经过后端发送到服务器上面，这段语句就变成了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">or</span> password <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这段话的意思就是password恒等于1，恒为true，所以不管怎么样，都能从数据库中查到东西。</p><p>这样，一个简单的sql注入就完成了。</p><p>那么，怎么解决此类问题呢？</p><p>这个时候我们就要用到预编译sql了。</p><p>在预编译sql里，我们会用？来代替#{}里面的内容，比如，我不把他写死，而是在接口里面将要传递的参数写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where password = #&#123;password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">select</span><span class="params">(String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在此时，java代码会有一个预编译的过程，将#{}用？代替，而实际上传递到数据库的参数就会变成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">or</span> password <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure><p>这样的话，即使你想输入上面的sql注入，其内容也会被替换成问号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;or 1=&#x27;</span><span class="number">1</span> 替换成 ？</span><br></pre></td></tr></table></figure><p>这样的话，传递到数据库的查询语句就会是password &#x3D; ？ ，这样显然是不符合语法的，所以并不能查出想要的结果。</p><p>自此，就可以很好的防止sql注入。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA文件上传代码优化</title>
      <link href="/2023/08/29/JAVA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
      <url>/2023/08/29/JAVA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>什么是文件上传？就是从客户端上传文件供他人下载或者展示给他人。</p><p>那么我们首先就需要把代码上传到服务器上面。以下拿图片文件作为例子：</p><p>在springboot中，为了方便，已经有写好的MultiparFile可以提供给我们使用。他的作用就是作为图片文件接收的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">upload</span><span class="params">(String username, Integer age, MultipartFile image)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//生成日志</span></span><br><span class="line">        log.info(<span class="string">&quot;文件上传：&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>, username, age, image);</span><br><span class="line">        <span class="comment">//通过getOriginalFilename()方法，获得image的文件名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">      <span class="comment">//将文件放到指定的磁盘目录</span></span><br><span class="line">        image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/yrq/Downloads/文件上传/&quot;</span> + originalFilename));</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个文件上传的代码我们就写好了。代码写好的同时，问题也随之而来。</p><p>问题一，如果同一时间有两个人上传同一个文件该怎么办呢？其结果就是，后一个上传的文件会覆盖上一个上传的文件。</p><p>问题二，如果传输的文件超过1mb的限制了该怎么办呢？</p><p>这里，我们先解决第一个问题。优化问题一的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">upload</span><span class="params">(String username, Integer age, MultipartFile image)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//打印日志</span></span><br><span class="line">      log.info(<span class="string">&quot;文件上传：&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>, username, age, image);</span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">        <span class="comment">//构造唯一的文件名（不能重复）--uuid（通用唯一识别码）</span></span><br><span class="line">        <span class="comment">//首先寻找到后缀名前面的那个.的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="comment">//然后分割出index索引后面的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">extname</span> <span class="operator">=</span> originalFilename.substring(index);</span><br><span class="line">        <span class="comment">//然后进行拼接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newFileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + extname;</span><br><span class="line">        <span class="comment">//打印日志</span></span><br><span class="line">        log.info(<span class="string">&quot;新的文件名:&#123;&#125;&quot;</span>,newFileName);</span><br><span class="line">      <span class="comment">//调用方法将文件储存在磁盘制定目录里面</span></span><br><span class="line">        image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/yrq/Downloads/文件上传/&quot;</span> + newFileName));</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向这样，就能解决同一时间两个或多个人上传同一文件的问题。</p><p>解决问题二的方法，我们可以在springboot的application.properties配置文件下加入这两条设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
